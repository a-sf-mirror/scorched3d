////////////////////////////////////////////////////////////////////////////////
//    Scorched3D (c) 2000-2009
//
//    This file is part of Scorched3D.
//
//    Scorched3D is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    Scorched3D is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with Scorched3D; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

#include <coms/ComsSyncLevelMessage.h>
#ifndef S3D_SERVER
#include <client/ScorchedClient.h>
#include <client/ClientSimulator.h>
#endif
#include <server/ScorchedServer.h>
#include <server/ServerSimulator.h>
#include <tank/TankTeamScore.h>
#include <tank/TankContainer.h>
#include <target/TargetContainer.h>
#include <common/Logger.h>
#include <map>

ComsMessageType ComsSyncLevelMessage::ComsSyncLevelMessageType("ComsSyncLevelMessageType");

ComsSyncLevelMessage::ComsSyncLevelMessage() :
	ComsMessage(ComsSyncLevelMessageType)
{
}

ComsSyncLevelMessage::~ComsSyncLevelMessage()
{
}

bool ComsSyncLevelMessage::writeMessage(NetBuffer &buffer)
{
	// Targets
	std::map<unsigned int, Target *> &targets =
		ScorchedServer::instance()->getTargetContainer().getTargets();
	buffer.addToBuffer((int) targets.size());
	std::map<unsigned int, Target *>::iterator targetItor;
	for (targetItor = targets.begin();
		targetItor != targets.end();
		targetItor++)
	{
		Target *target = targetItor->second;
		buffer.addToBuffer(target->getPlayerId());
		if (target->isTarget())
		{
			if (!target->writeMessage(buffer)) return false;		
		}
		else
		{
			if (!((Tank *)target)->writeMessage(buffer, true)) return false;
		}
	}

	// Team score
	if (!ScorchedServer::instance()->getContext().getTankTeamScore().writeMessage(buffer)) return false;

	// Simulator state
	if (!ScorchedServer::instance()->getServerSimulator().writeSyncMessage(buffer)) return false;

	// Send landscape deforms
	deformInfos_ = DeformLandscape::getInfos();
	buffer.addToBuffer((int) deformInfos_.size());
	{
		std::vector<DeformLandscape::DeformInfo>::iterator itor;
		for (itor = deformInfos_.begin();
			itor != deformInfos_.end();
			itor++)
		{
			DeformLandscape::DeformInfo &info = *itor;
			buffer.addToBuffer(info.type);
			buffer.addToBuffer(info.pos);
			buffer.addToBuffer(info.radius);
		}
	}	

	return true;
}

bool ComsSyncLevelMessage::readMessage(NetBufferReader &reader)
{
#ifndef S3D_SERVER
	// Update all targets with the state from the targets on the server
	// also add any new targets the server may have created
	int targetCount = 0;
	if (!reader.getFromBuffer(targetCount)) return false;
	std::set<unsigned int> usedTargetIds;
	for (int i=0; i<targetCount; i++)
	{
		unsigned int playerId;
		if (!reader.getFromBuffer(playerId)) return false;
		usedTargetIds.insert(playerId);

		if (playerId >= TargetID::MIN_TANK_ID &&
			playerId <  TargetID::MAX_TANK_ID)
		{
			// Tank
			Tank *tank = ScorchedClient::instance()->getTankContainer().
				getTankById(playerId);
			if (tank)
			{
				if (!tank->readMessage(reader)) return false;
			}
			else
			{
				std::string name;
				reader.getFromBuffer(name);
				Logger::log(S3D::formatStringBuffer("Error: Failed to find tank %u\"%s\"",
					playerId, name.c_str()));

				std::map<unsigned int, Tank *> &tanks = 
					ScorchedClient::instance()->getTankContainer().getAllTanks();
				std::map<unsigned int, Tank *>::iterator itor;
				for (itor = tanks.begin();
					itor != tanks.end();
					itor++)
				{
					Tank *tank = itor->second;
					Logger::log(S3D::formatStringBuffer("  Possible tank %u\"%s\"",
						tank->getPlayerId(), tank->getCStrName().c_str()));
				}

				return false;
			}
		}
		else 
		{
			// Target
			Target *target = ScorchedClient::instance()->getTargetContainer().
				getTargetById(playerId);
			
			if (playerId >= TargetID::MIN_TARGET_ID &&
				playerId < TargetID::MIN_TARGET_TRANSIENT_ID)
			{
				// Target (generated by level code at start of level)
				if (target)
				{
					if (!target->readMessage(reader)) return false;
				}
				else
				{
					// Should never happen
					Logger::log(S3D::formatStringBuffer("Error: Failed to find level target %u",
						playerId));
					return false;
				}
			}
			else if (playerId >= TargetID::MIN_TARGET_TRANSIENT_ID &&
				playerId < TargetID::MAX_TARGET_ID)
			{
				// Target (generated during play)
				if (target)
				{
					// Should never happen
					if (!target->readMessage(reader)) return false;
				}
				else
				{
					Target *newTarget = new Target(
						playerId, 
						LangString(), 
						ScorchedClient::instance()->getContext());
					if (!newTarget->readMessage(reader))
					{
						Logger::log("ClientNewGameHandler: Failed to parse new target message");
						return false;
					}

					ScorchedClient::instance()->getTargetContainer().addTarget(newTarget);
				}
			}
		}
	}

	// Remove any targets that have been removed due to game play
	std::map<unsigned int, Target *> targets =
		ScorchedClient::instance()->getTargetContainer().getTargets(); // Copy
	std::map<unsigned int, Target *>::iterator targetItor;
	for (targetItor = targets.begin();
		targetItor != targets.end();
		targetItor++)
	{
		Target *target = targetItor->second;
		if (target->getPlayerId() >= TargetID::MIN_TARGET_ID &&
			target->getPlayerId() < TargetID::MIN_TARGET_TRANSIENT_ID)
		{
			if (usedTargetIds.find(target->getPlayerId()) ==
				usedTargetIds.end())
			{
				if (target->isTarget())
				{
					Target *removedTarget = 
						ScorchedClient::instance()->getTargetContainer().removeTarget(target->getPlayerId());
					delete removedTarget;
				}
				else
				{
					// Should never happen as tanks (even temporary ones) aren't removed
					// from the container set when killed
					Tank *removedTank = 
						ScorchedClient::instance()->getTankContainer().removeTank(target->getPlayerId());
					delete removedTank;
				}
			}
		}
	}

	// Get the tank team
	if (!ScorchedClient::instance()->getContext().getTankTeamScore().readMessage(reader)) return false;

	// Simulator state
	if (!ScorchedClient::instance()->getClientSimulator().readSyncMessage(reader)) return false;

	// Get the landscape deforms
	int infosSize = 0;
	if (!reader.getFromBuffer(infosSize)) return false;
	for (int i=0; i<infosSize; i++)
	{
		DeformLandscape::DeformInfo info;
		if (!reader.getFromBuffer(info.type)) return false;
		if (!reader.getFromBuffer(info.pos)) return false;
		if (!reader.getFromBuffer(info.radius)) return false;
		deformInfos_.push_back(info);
	}
#endif
	
	return true;
}
